<html>
    <head>
        <meta http-equiv="Content-Type" content = "text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width,user-scalable=yes">
        <title>webgldeferred</title>
        <script src = "defferd1week.js" type ="text/javascript"></script>

        <script id = "vs" type = "x-shader/x-vertex">
        
        attribute vec3 position;

        void main(void){
            gl_Position = vec4(position,1.0);
        }
    
        </script>

        <script id = "fs" type = "x-shader/x-fragment">
        #extension GL_EXT_draw_buffers : require
 
        precision mediump float;
        uniform float time;
        uniform vec2 resolution;
        uniform vec3 campos;
        float pi = 3.1415926535;
        mat2 rot(float r){
            return mat2(cos(r),sin(r),-sin(r),cos(r));
        }

        float random (vec2 st) {
            return fract(sin(dot(st.xy,
                                 vec2(12.9898,78.233)))*
                43758.5453123);
        }
        float noise (in vec2 st) {
            vec2 i = floor(st);
            vec2 f = fract(st);
        
            // Four corners in 2D of a tile
            float a = random(i);
            float b = random(i + vec2(1.0, 0.0));
            float c = random(i + vec2(0.0, 1.0));
            float d = random(i + vec2(1.0, 1.0));
        
            // Smooth Interpolation
        
            // Cubic Hermine Curve.  Same as SmoothStep()
            vec2 u = f*f*(3.0-2.0*f);
            // u = smoothstep(0.,1.,f);
        
            // Mix 4 coorners percentages
            return mix(a, b, u.x) +
                    (c - a)* u.y * (1.0 - u.x) +
                    (d - b) * u.x * u.y;
        }
        vec2 random2( ivec2 p ) {
            return fract(sin(vec2(dot(vec2(p),vec2(127.1,311.7)),dot(vec2(p),vec2(269.5,183.3))))*43758.5453);
        }
        
        float maxabs(vec2 p){return max(abs(p.x), abs(p.y));}

        float voronoi(vec2 uv){
            uv *= 2.0;
            vec2 i = floor(uv);
            vec2 f = fract(uv);
        
            vec2 res = vec2(8.0);
            for(int x = -1; x <=1; x++){
              for(int y = -1; y <=1; y++){
                vec2 n = vec2(x,y);
                vec2 np = vec2(random(i + n),random(i + n + vec2(12.56,64.66)));
                vec2 p = n + np - f;
                float d = abs(p.x) + abs(p.y);
                if(d < res.x){
                  res.y = res.x;
                  res.x = d;
                } else if(d < res.y){
                  res.y = d;
                }
              }
            }
            float  c = res.y - res.x;
            c = sqrt(c);
            c = smoothstep(0.4,0.0,c);
            return c;
          }
        
        float cube(vec3 p,vec3 s){
            vec3 q = abs(p);
            vec3 m = max(s-q,0.0);
            return length(max(q-s,0.))-min(min(m.x,m.y),m.z);
        }

        
        float cylin( vec3 p, float h, float r )
        {
        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);
        return min(max(d.x,d.y),0.0) + length(max(d,0.0));
        }

        float octahedron(vec3 p, float s){
            p = abs(p);
            float m = p.x+p.y+p.z-s;
            vec3 q;
                if( 3.0*p.x < m ) q = p.xyz;
            else if( 3.0*p.y < m ) q = p.yzx;
            else if( 3.0*p.z < m ) q = p.zxy;
            else return m*0.57735027;
                
            float k = clamp(0.5*(q.z-q.y+s),0.0,s); 
            return length(vec3(q.x,q.y-s+k,q.z-k)); 
        }

        float boxring(vec3 p,vec2 rd,vec2 s){
            vec2 qp = abs(p.xz);
            vec2 qm = max(rd-qp,0.);
            float r1 = length(max(qp-rd,0.))-min(qm.x,qm.y);
            vec2 q = abs(vec2(r1,p.y));
            vec2 m = max(s-q,0.);
            return length(max(q-s,0.))-min(m.x,m.y);
        }

        float ring(vec3 p,float r,vec2 s){
            vec2 q = abs(vec2(length(p.xz)-r,p.y));
            vec2 m = max(s-q,0.);
            return length(max(q-s,0.))-min(m.x,m.y);
        }

      
        float obfl(vec3 p){
            vec3 sp = p;
            // vec3 skr = vec3(length(p),atan(length(p.xz),p.y),atan(p.x,p.z));
            //p = skr.x*vec3(sin(skr.y)*cos(skr.z),cos(skr.y),sin(skr.y)*sin(skr.z));

            p.xz = abs(p.xz);

            float kt = 0.1;

            for(int i = 0;i<4;i++){
                p.y = abs(p.y)-0.4;
                p.yz *= rot(kt);
                p.xy *= rot(kt);
            }
     
            float d1 =boxring(p,vec2(3.),vec2(0.03));
            p = sp;
            float d = octahedron(p,2.5);
            d = min(d,d1);
            return d;
        }


        float stage(vec3 p){
            p.y = abs(p.y)-13.;
            return cylin(p,7.-clamp(-p.y-6.7,0.,1.1),8.);
        }

        float capring(vec3 p){
            float cd = length(p.xz)-6.;
          //  p.y = abs(p.y)-6.5;
            
            vec2 skr = vec2(length(p.xz),atan(p.x,p.z));

            for(int i =0;i<4;i++){
                float fi =float(i);
                
                float es = skr.x-9.2/pow(2.,fi);
                skr.x = abs(es);
            
                skr.y += (fi+2.)*0.1*sign(es)*(time);
            }
            p.xz = skr.x*vec2(cos(skr.y),sin(skr.y));
         
            float d2 = ring(p,0.2,vec2(0.2,0.3));
            p -= vec3(0.3,0,0);
            p.xz *= rot(pi/4.);
            d2 = max(d2,-cube(p,vec3(0.3,0.5,0.3)));
            d2 = max(d2,-cd);
            return d2;
        }

        float wall (vec3 p){
            return -cube(p,vec3(30,11.,30.));
        }

        float capring2(vec3 p){
            float cd = length(p.xz)-8.;
            p.y = abs(p.y)-7.5;
            
            p.y = abs(p.y) -0.4;

            float csw = min(cube(p,vec3(0.2,0.2,20.)),cube(p,vec3(20.,0.2,0.2)));
            
            vec2 skr = vec2(length(p.xz),atan(p.x,p.z));

            for(int i =0;i<4;i++){
                float fi =float(i);
                
                float es = skr.x-10./pow(2.,fi);
                skr.x = abs(es);
            
          
            }
            p.xz = skr.x*vec2(cos(skr.y),sin(skr.y));
         

            float d2 = ring(p,1.,vec2(0.4,.2));
      
            d2 = max(d2,-cd);
            d2 = min(d2,csw);
            return d2;
        }

        vec2 pmod(vec2 p,float n){
            float np = 3.14159265*2.0/n;
            float r = atan(p.x,p.y)-0.5*np;
            r = mod(r,np)-0.5*np;
            return length(p)*vec2(cos(r),sin(r));
          }

        float particle(vec3 p){
            p.xz = pmod(p.xz,8.);
            p.y -= time;
            float k = 5.;
            p.x = abs(p.x-7.5)-3.5;
            p.y = mod(p.y,k)-0.5*k;
            return length(p)-0.1;
        }

        vec4 dist(vec3 p){
            float dob = obfl(p);
            float dstage = stage(p);
            float dwall = wall(p);
            float dcapring = capring(p);
            float dcapring2 = capring2(p);
            float particle = particle(p);
   

            float d;
            vec3 col = vec3(1.,1.,1.);
            d = min(dob,dwall);
            d = min(d,dstage);
            d = min(d,dcapring);
            d = min(d,dcapring2);
            d = min(d,particle);
            return vec4(col,d);
        }

        vec3 getNormal(vec3 p){
            vec2 e = vec2(0.0001,0.);
            return normalize(vec3(
                dist(p+e.xyy).w-dist(p-e.xyy).w,
                dist(p+e.yxy).w-dist(p-e.yxy).w,
                dist(p+e.yyx).w-dist(p-e.yyx).w
            ));
        }

        void main(){
            vec2 p = (gl_FragCoord.xy*2.0-resolution)/min(resolution.x,resolution.y);
            float krt = time;
            float radi = 18.;
            vec3 ro = vec3(radi*cos(krt),3.,radi*sin(krt));
            ro = campos;
            vec3 ta = vec3(0);
            vec3 cdir = normalize(ta-ro);
            vec3 side = cross(cdir,vec3(0,1,0));
            vec3 up = cross(side,cdir);
            vec3 rd = normalize(p.x*side+p.y*up+cdir*0.9);

            float d,t=0.;
            vec4 vd;
            float minimum = 0.001;
            float maximum = 100.;
            for(int i =0;i<140;i++){
                vd = dist(ro+rd*t);
                d = vd.w;
                t += d*.8;
                if(d<minimum||t>maximum)break;
            }
            vec3 sp = ro+rd*t;
            float metallic = 0.;
            float roughness = 0.;
            float ems = 0.;
            vec3 col = vec3(0);
            vec3 normal = vec3(0);

            float refmetallic = 0.;
            float refroughness = 0.;
            float refems = 0.;
            vec3 refsp = vec3(0);
            vec3 refcol= vec3(0);
            vec3 refnormal =vec3(0);
            int refbool = 0;
            if(d<minimum){
                col = vec3(0.3);
                metallic = 0.3;
                roughness = 0.3;
                ems = 0.;
                if(obfl(sp)<minimum) col = vec3(0.1,0.9,0.9),metallic =0.5,roughness =1.;
                if(stage(sp)<minimum) col = vec3(0.05,0.2,0.9),roughness=1.;
                if(capring(sp)<minimum) col = vec3(0.1,0.9,.1),ems = 0.1;
                if(particle(sp)<minimum) col = vec3(1,1,1),ems= 1.,metallic =0.,roughness =0.;
                
                normal = getNormal(sp);
                if(wall(sp)<minimum+0.1){
                    float ns = 0.1;
                    float zn =voronoi(sp.xy*ns);
                    float yn =voronoi(sp.zx*ns);
                    float xn =voronoi(sp.yz*ns);
                    float kemt = time*0.6;
                    float ker = 0.2;
                    float edb = clamp(sin(sp.y*ker+kemt),0.,1.)*step(0.8,abs(normal.x))*xn+clamp(sin(sp.x*ker+kemt),0.,1.)*step(0.8,abs(normal.y))*yn+clamp(sin(sp.y*ker+kemt),0.,1.)*step(0.8,abs(normal.z))*zn;
                    col =  vec3(0.1,0.9,0.9)*edb,ems = 1.*edb;
                    normal -= .9*(
                        sign(normal.x)*step(0.8,abs(normal.x))*vec3(0,xn,xn)+
                        sign(normal.y)*step(0.8,abs(normal.y))*vec3(yn,0,yn)+
                        sign(normal.z)*step(0.8,abs(normal.z))*vec3(zn,zn,0));
                    normal = normalize(normal);
                }

                t = 0.1;
                ro = sp;
                float sna = 30.;
                rd = reflect(rd,normal);
                float minimum = 0.01;
                float maximum = 50.;
                for(int i =0;i<60;i++){
                    vd = dist(ro+rd*t);
                    d = vd.w;
                    t += d*.8;
                    if(d<minimum||t>maximum)break;
                }
                
                refsp = ro+rd*t;
                refcol = vec3(0);
                refnormal = vec3(0);
                if(d<minimum){
                    refnormal = getNormal(sp);
                    refcol = vec3(0.3);
                    if(obfl(refsp)<minimum) refcol = vec3(0.1,0.9,0.9),refmetallic =0.5,refroughness = 1.;
                    if(stage(refsp)<minimum) refcol = vec3(0.05,0.2,0.9),refroughness=1.;
                    if(capring(refsp)<minimum) refcol = vec3(0.1,0.9,.1),refems=.2;
                    if(particle(sp)<minimum) refcol = vec3(1,1,1),refems= 1.,refmetallic =0.,refroughness = 0.;
                    
                    refbool = 1;
                    if(wall(sp)<minimum+0.1){
                        float ns = 0.1;
                        float zn =voronoi(refsp.xy*ns);
                        float yn =voronoi(refsp.zx*ns);
                        float xn =voronoi(refsp.yz*ns);
                        float kemt = time*0.6;
                        float ker = .2;
                        float edb = clamp(sin(refsp.y*ker+kemt),0.,1.)*step(0.8,abs(refnormal.x))*xn+clamp(sin(refsp.x*ker+kemt),0.,1.)*step(0.8,abs(refnormal.y))*yn+clamp(sin(refsp.y*ker+kemt),0.,1.)*step(0.8,abs(refnormal.z))*zn;
                        col =  vec3(0.1,0.9,0.9)*edb,ems = 1.*edb;
                        refnormal -= .9*(
                            sign(refnormal.x)*step(0.8,abs(refnormal.x))*vec3(0,xn,xn)+
                            sign(refnormal.y)*step(0.8,abs(refnormal.y))*vec3(yn,0,yn)+
                            sign(refnormal.z)*step(0.8,abs(refnormal.z))*vec3(zn,zn,0));
                        refnormal = normalize(refnormal);
                    }
    
                }
    

            
            }


            vec2 uv = gl_FragCoord.xy/resolution;
            gl_FragData[0] = vec4(col,metallic);
            gl_FragData[1] = vec4(normal,roughness);
            gl_FragData[2] = vec4(sp,ems);
            gl_FragData[3] =  vec4(refcol,refmetallic);
            gl_FragData[4] =  vec4(refnormal,refroughness);
            gl_FragData[5] =  vec4(refsp,refems);
            gl_FragData[6] = vec4(1,0,1,1);
         
        }
        
        </script>
        <script id = "preview_vs" type = "x-shader/x-vertex">
        attribute vec3 position;

        
        void main(){
            gl_Position = vec4(position, 1.0);
        }
         </script>
        <script id = "preview_fs" type = "x-shader/x-fragment">
        #extension GL_EXT_draw_buffers : require
        precision mediump float;
        
        uniform float time;
        uniform vec2 resolution;
        uniform vec3 campos;
        uniform sampler2D texture0;
        uniform sampler2D texture1;
        uniform sampler2D texture2;
        uniform sampler2D texture3;
        uniform sampler2D texture4;
        uniform sampler2D texture5;
        uniform sampler2D texture6;

        #define saturate(x) clamp(x,0.,1.)
        #define EPSILON 1e-6
        #define PI  3.14159265359

        
        #define SAMPLES 16
        #define INTENSITY 5.
        #define SCALE 2.5
        #define BIAS 0.05
        #define SAMPLE_RAD 0.02
        #define MAX_DISTANCE 4.0
        #define MOD3 vec3(.1031,.11369,.13787)

        float hash12(vec2 p)
        {
            vec3 p3  = fract(vec3(p.xyx) * MOD3);
            p3 += dot(p3, p3.yzx + 19.19);
            return fract((p3.x + p3.y) * p3.z);
        }

        vec2 hash22(vec2 p)
        {
            vec3 p3 = fract(vec3(p.xyx) * MOD3);
            p3 += dot(p3, p3.yzx+19.19);
            return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));
        }

        float doAmbientOcclusion(in vec2 tcoord,in vec2 uv, in vec3 p, in vec3 cnorm)
        {
            vec3 diff = texture2D(texture2,tcoord + uv).xyz - p;
            float l = length(diff);
            vec3 v = diff/l;
            float d = l*SCALE;
            float ao = max(0.0,dot(cnorm,v)-BIAS)*(1.0/(1.0+d));
            ao *= smoothstep(MAX_DISTANCE,MAX_DISTANCE * 0.5, l);
            return ao;

        }

        float spiralAO(vec2 uv, vec3 p, vec3 n, float rad)
        {
            float goldenAngle = 2.4;
            float ao = 0.;
            float inv = 1. / float(SAMPLES);
            float radius = 0.;

            float rotatePhase = hash12( uv*100. ) * 6.28;
            float rStep = inv * rad;
            vec2 spiralUV;

            for (int i = 0; i < SAMPLES; i++) {
                spiralUV.x = sin(rotatePhase);
                spiralUV.y = cos(rotatePhase);
                radius += rStep;
                ao += doAmbientOcclusion(uv, spiralUV * radius, p, n);
                rotatePhase += goldenAngle;
            }
            ao *= inv;
            return ao;
        }


        vec3 DiffuseBRDF(vec3 diffuseColor) {
            return diffuseColor / PI;
        }
        
        vec3 F_Schlick(vec3 specularColor, vec3 H, vec3 V) {
            return (specularColor + (1.0 - specularColor) * pow(1.0 - saturate(dot(V,H)), 5.0));
        }
        
        float D_GGX(float a, float dotNH) {
            float a2 = a*a;
            float dotNH2 = dotNH*dotNH;
            float d = dotNH2 * (a2 - 1.0) + 1.0;
            return a2 / (PI * d * d);
        }
        
        float G_Smith_Schlick_GGX(float a, float dotNV, float dotNL) {
            float k = a*a*0.5 + EPSILON;
            float gl = dotNL / (dotNL * (1.0 - k) + k);
            float gv = dotNV / (dotNV * (1.0 - k) + k);
            return gl*gv;
        }
        
        // Cook-Torrance
        vec3 SpecularBRDF(vec3 ld, vec3 normal,vec3 vd, vec3 specularColor, float roughnessFactor) {
        
            vec3 N = normal;
            vec3 V = vd;
            vec3 L = ld;
        
            float dotNL = saturate(dot(N,L));
            float dotNV = saturate(dot(N,V));
            vec3 H = normalize(L+V);
            float dotNH = saturate(dot(N,H));
            float dotVH = saturate(dot(V,H));
            float dotLV = saturate(dot(L,V));
            float a = roughnessFactor * roughnessFactor;
        
            float D = D_GGX(a, dotNH);
            float G = G_Smith_Schlick_GGX(a, dotNV, dotNL);
            vec3 F = F_Schlick(specularColor, V, H);
            return (F*(G*D))/(4.0*dotNL*dotNV+EPSILON);
        }
        

        vec3 calcdiffuse(vec3 diffusecol,vec3 ld,vec3 lightcol, vec3 normal,vec3 vd, vec3 specularColor, float roughnessFactor){
            float dotNL = saturate(dot(normal, ld));
            vec3 irradiance = dotNL * lightcol;

            irradiance *= PI;
            return irradiance * DiffuseBRDF(diffusecol);
        }
        vec3 calcspec(vec3 diffusecol,vec3 ld,vec3 lightcol, vec3 normal,vec3 vd, vec3 specularColor, float roughnessFactor){
            float dotNL = saturate(dot(normal, ld));
            vec3 irradiance = dotNL * lightcol;

            irradiance *= PI;
            return irradiance*irradiance * SpecularBRDF(ld, normal,vd, specularColor, roughnessFactor);
        }

        vec3 coloring(vec3 pos,vec3 normal,vec3 vd,vec3 difcol,float metallic,float roughness,float ems){
            vec3 albedo = difcol;
            vec3 diffuseColor = mix(albedo, vec3(0.0), metallic);
            vec3 specularColor = mix(vec3(0.04), albedo, metallic);
            float specularRoughness = roughness;
            vec3 reflectdiffuse = vec3(0);
            vec3 reflectspec = vec3(0);

            vec3 lpos = vec3(0,5,0);
            vec3 ld = -normalize(pos-lpos);
            vec3 lightcol = vec3(0.1);
            reflectdiffuse += calcdiffuse(diffuseColor,ld,lightcol,normal,vd,specularColor,specularRoughness);
            reflectspec += calcspec(diffuseColor,ld,lightcol,normal,vd,specularColor,specularRoughness);

            lpos = vec3(16,0,0);
            ld = -normalize(pos-lpos);
            lightcol = vec3(0.1,0.3,0.1);
            reflectdiffuse += calcdiffuse(diffuseColor,ld,lightcol,normal,vd,specularColor,specularRoughness);
            reflectspec += calcspec(diffuseColor,ld,lightcol,normal,vd,specularColor,specularRoughness);
        
            lpos = vec3(-3,0,3);
            ld = -normalize(pos-lpos);
            lightcol = vec3(0.1,0.1,0.7);
            reflectdiffuse += calcdiffuse(diffuseColor,ld,lightcol,normal,vd,specularColor,specularRoughness);
            reflectspec += calcspec(diffuseColor,ld,lightcol,normal,vd,specularColor,specularRoughness);

            lpos = vec3(-8,0,3);
        
            ld = -normalize(pos-lpos);
            lightcol = vec3(0.2);
            reflectdiffuse += calcdiffuse(diffuseColor,ld,lightcol,normal,vd,specularColor,specularRoughness);
            reflectspec += calcspec(diffuseColor,ld,lightcol,normal,vd,specularColor,specularRoughness);

            return reflectdiffuse+reflectspec+ems*difcol;
            
        }

        void main(){
            vec2 p = (gl_FragCoord.xy*2.0-resolution)/min(resolution.x,resolution.y);
            
            vec2 uv = gl_FragCoord.xy/resolution;
            vec4 t0 = texture2D(texture0, uv);
            vec3 difcol = t0.xyz;
            float metallic = t0.w;
            vec4 t1 =  texture2D(texture1, uv);
            vec3 normal =t1.xyz;
            float roughness = t1.w;
            vec4 t2 =  texture2D(texture2,uv);
            vec3 pos =t2.xyz;
            float ems = t2.w;
            
            
            vec4 t3 = texture2D(texture3,uv);
            vec3 refdifcol = t3.xyz;
            float refmetallic = t3.w;
            vec4 t4 = texture2D(texture4,uv);
            vec3 refnormal = t4.xyz;
            float refroughness = t4.w;
            vec4 t5 =  texture2D(texture5,uv);
            vec3 refpos =t5.xyz;
            float refems = t5.w;
            
            vec4 t6 =  texture2D(texture6,uv);
            
            vec3 vd = normalize(campos-pos);
            vec3 refvd = normalize(pos-refpos);

           

            vec3 col = vec3(0);
            vec3 rrx = vec3(0);
            rrx = coloring(refpos,refnormal,refvd,refdifcol,metallic,roughness,refems);
            col = coloring(pos,normal,vd,difcol,metallic,roughness,ems)+rrx*metallic;
           
           // col += 0.0001/t6.x;

            float ao = 0.;
            float rad = SAMPLE_RAD/pos.z;

            ao = spiralAO(uv, pos, normal, rad);

            ao = 1.0-ao * INTENSITY;

                    
          
               
            
            
            col *= vec3(ao);

         
           gl_FragData[0] =vec4(col,1.);//vec4(t6.xyz,ao);
        }


        </script>


        </script>
        <script id = "post_vs" type = "x-shader/x-vertex">
        attribute vec3 position;

        
        void main(){
            gl_Position = vec4(position, 1.0);
        }
        </script>
        <script id = "post_fs" type = "x-shader/x-fragment">
        precision mediump float;
        
        uniform float time;
        uniform vec2 resolution;
        uniform sampler2D texture7;
   
        void main(){
            vec2 p = (gl_FragCoord.xy*2.0-resolution)/min(resolution.x,resolution.y);
            
            vec2 uv = gl_FragCoord.xy/resolution;
           
            vec3 col = texture2D(texture7, uv).xyz;
            float a = texture2D(texture7, uv).w;
            gl_FragColor = vec4(col,1.);
        }


        </script>

        <style>
            *{
            margin: 0;
            padding: 0;
        }
        #canvas{
            display: block;
        }
        html, body, #wrapper{
            width: 100%;
            height: 100%;
        }

        </style>
    </head>

    
    <body>
        <div id="wrapper">
            <canvas id="canvas" width="" height=""></canvas>
        </div>
    </body>
</html>